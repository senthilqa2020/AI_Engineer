# Program: Book Class Implementation
# Matches the assignment: title, author, publication_year, and get_age()

import datetime

class Book:
    def __init__(self, title: str, author: str, publication_year: int):
        self.title = title
        self.author = author
        self.publication_year = publication_year

    def get_age(self) -> int:
        """Return the age of the book in years (current year - publication_year)."""
        current_year = datetime.datetime.now().year
        return current_year - self.publication_year


if __name__ == "__main__":
    # Example usage (as shown in the assignment)
    book1 = Book("Python Basics", "John Doe", 2015)
    print("Book Age:", book1.get_age(), "years")

    # --- Optional: interactive input (useful for quick testing in the terminal) ---
    try:
        print("\nEnter your own book details:")
        title = input("Title: ").strip()
        author = input("Author: ").strip()
        pub_year = int(input("Publication year (e.g., 2015): ").strip())

        user_book = Book(title, author, pub_year)
        print("Book Age:", user_book.get_age(), "years")
    except ValueError:
        print("Please enter a valid number for the publication year.")

# Program: Managing Student Records (Assignment 7)

class Student:
    def __init__(self, name: str, grade: str, department: str):
        self.name = name
        self.grade = grade
        self.department = department

    def print_info(self) -> None:
        """Print all details of the student in a readable format."""
        print(f"Name       : {self.name}")
        print(f"Grade      : {self.grade}")
        print(f"Department : {self.department}")
        print("-" * 30)

    def update_grade(self, new_grade: str) -> None:
        """Update the student's grade."""
        self.grade = new_grade


def print_all_students(students: list) -> None:
    """Helper to display multiple student records."""
    print("\n=== Student Records ===")
    for s in students:
        s.print_info()


if __name__ == "__main__":
    # Create at least three Student objects with different details
    student1 = Student("Aarav Kumar", "A", "Computer Science")
    student2 = Student("Diya Sharma", "B", "Electronics")
    student3 = Student("Vikram Rao", "C", "Mechanical")

    # Store multiple students in a list for easy management
    students = [student1, student2, student3]

    # Print each student's information
    print_all_students(students)

    # Update the grade of one student and print the updated details
    print(">>> Updating Diya's grade from B to A- ...\n")
    student2.update_grade("A-")

    # Show updated records
    print_all_students(students)

    # --- Optional: demonstrate adding a new record dynamically ---
    # new_student = Student("Neha Gupta", "B+", "Information Technology")
    # students.append(new_student)
    # print_all_students(students)

# Program 8: List Slicing and Indexing

# Given list of first ten prime numbers
prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# a) Extract the middle five primes
middle_five = prime_numbers[2:7]

# b) Get every second prime (starting from beginning)
every_second = prime_numbers[::2]

# c) Use negative indexing to get last three primes
last_three = prime_numbers[-3:]

# d) Reverse the list
reversed_list = prime_numbers[::-1]

# e) Descending order sort
descending_sorted = sorted(prime_numbers, reverse=True)

# Print results
print("Original List       :", prime_numbers)
print("Middle Five Primes  :", middle_five)
print("Every Second Prime  :", every_second)
print("Last Three Primes   :", last_three)
print("Reversed List       :", reversed_list)
print("Descending Order    :", descending_sorted)

# Program 9: Bank Account System with OOPs

class BankAccount:
    def __init__(self, account_holder: str, balance: float, account_type: str):
        self.account_holder = account_holder
        self.balance = balance
        self.account_type = account_type

    def deposit(self, amount: float) -> None:
        """Increase balance by the given amount."""
        if amount > 0:
            self.balance += amount
            print(f"Deposited: {amount}")
        else:
            print("Deposit amount must be positive!")

    def withdraw(self, amount: float) -> None:
        """Decrease balance if sufficient funds are available."""
        if amount <= 0:
            print("Withdrawal amount must be positive!")
        elif amount > self.balance:
            print("Insufficient balance")
        else:
            self.balance -= amount
            print(f"Withdrew: {amount}")

    def display_balance(self) -> None:
        """Display account details and current balance."""
        print("\n=== Account Details ===")
        print(f"Account Holder: {self.account_holder}")
        print(f"Account Type  : {self.account_type}")
        print(f"Balance       : {self.balance:.2f}")
        print("=======================\n")


if __name__ == "__main__":
    # Create two accounts
    account1 = BankAccount("Aarav Kumar", 5000.0, "Savings")
    account2 = BankAccount("Diya Sharma", 10000.0, "Current")

    # Perform operations on account1
    account1.display_balance()
    account1.deposit(1500)
    account1.display_balance()
    account1.withdraw(2000)
    account1.display_balance()
    account1.withdraw(6000)  # should trigger "Insufficient balance"

    # Perform operations on account2
    account2.display_balance()
    account2.deposit(2500)
    account2.display_balance()
    account2.withdraw(12000)  # should trigger "Insufficient balance"
    account2.withdraw(5000)
    account2.display_balance()

# Program 10: Bug Tracking System

class BugTracker:
    def __init__(self):
        # Dictionary to store bugs
        # Format: { bug_id: {"description": str, "severity": str, "status": str} }
        self.bugs = {}

    def add_bug(self, bug_id: str, description: str, severity: str) -> None:
        """Add a new bug with default status 'Open'."""
        if bug_id in self.bugs:
            print(f"Bug ID {bug_id} already exists!")
        else:
            self.bugs[bug_id] = {
                "description": description,
                "severity": severity,
                "status": "Open"
            }
            print(f"Bug {bug_id} added successfully.")

    def update_status(self, bug_id: str, new_status: str) -> None:
        """Update the status of an existing bug."""
        if bug_id in self.bugs:
            self.bugs[bug_id]["status"] = new_status
            print(f"Bug {bug_id} status updated to {new_status}.")
        else:
            print(f"Bug ID {bug_id} not found!")

    def list_all_bugs(self) -> None:
        """Print details of all bugs in a readable format."""
        if not self.bugs:
            print("No bugs found.")
        else:
            print("\n=== Bug Records ===")
            for bug_id, details in self.bugs.items():
                print(f"Bug ID      : {bug_id}")
                print(f"Description : {details['description']}")
                print(f"Severity    : {details['severity']}")
                print(f"Status      : {details['status']}")
                print("-" * 30)


if __name__ == "__main__":
    # Create BugTracker object
    tracker = BugTracker()

    # Add at least three bugs
    tracker.add_bug("BUG001", "Login button not working", "High")
    tracker.add_bug("BUG002", "Profile picture upload fails", "Medium")
    tracker.add_bug("BUG003", "Settings page loads slowly", "Low")

    # Update statuses
    tracker.update_status("BUG002", "In Progress")
    tracker.update_status("BUG003", "Closed")

    # List all bugs
    tracker.list_all_bugs()
